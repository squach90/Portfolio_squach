import { z } from "zod";
type OptionalKeys<T> = {
    [K in keyof T]-?: Record<string, unknown> extends Pick<T, K> ? K : never;
}[keyof T];
type FilteredKeys<T, U> = {
    [K in keyof T as T[K] extends U ? K : never]: T[K];
};
export declare const queryNumberArray: z.ZodEffects<z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber]>, z.ZodArray<z.ZodNumber, "many">]>, number[], string | number | number[]>;
export declare const queryStringArray: z.ZodUnion<[z.ZodEffects<z.ZodArray<z.ZodString, "many">, string[], unknown>, z.ZodArray<z.ZodString, "many">]>;
export declare function useTypedQuery<T extends z.AnyZodObject>(schema: T): {
    data: z.TypeOf<T>;
    setQuery: <J extends keyof z.TypeOf<T>>(key: J, value: z.TypeOf<T>[J]) => void;
    removeByKey: (key: OptionalKeys<z.TypeOf<T>>) => void;
    pushItemToKey: <J_1 extends keyof FilteredKeys<Required<z.TypeOf<T>>, unknown[]>>(key: J_1, value: FilteredKeys<Required<z.TypeOf<T>>, unknown[]>[J_1][number]) => void;
    removeItemByKeyAndValue: <J_2 extends keyof FilteredKeys<Required<z.TypeOf<T>>, unknown[]>>(key: J_2, value: FilteredKeys<Required<z.TypeOf<T>>, unknown[]>[J_2][number]) => void;
    removeAllQueryParams: () => void;
};
export {};
//# sourceMappingURL=useTypedQuery.d.ts.map