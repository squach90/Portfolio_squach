import type { EventType } from '../prisma-client';
import dayjs from '../dayjs';
export declare class BookingDateInPastError extends Error {
    constructor(message?: string);
}
/**
 * Dates passed to this function are timezone neutral.
 */
export declare function calculatePeriodLimits({ periodType, periodDays, periodCountCalendarDays, periodStartDate, periodEndDate, 
/**
 * These dates will be considered in the same utfcOffset as provided
 */
allDatesWithBookabilityStatus, utcOffset, 
/**
 * This is temporary till we find a way to provide allDatesWithBookabilityStatus in handleNewBooking without re-computing availability.
 * It is okay for handleNewBooking to pass it as true as the frontend won't allow selecting a timeslot that is out of bounds of ROLLING_WINDOW
 * But for the booking that happen through API, we absolutely need to check the ROLLING_WINDOW limits.
 */
_skipRollingWindowCheck, }: Pick<EventType, "periodType" | "periodDays" | "periodCountCalendarDays" | "periodStartDate" | "periodEndDate"> & {
    allDatesWithBookabilityStatus: Record<string, {
        isBookable: boolean;
    }> | null;
    utcOffset: number;
    _skipRollingWindowCheck?: boolean;
}): PeriodLimits;
export declare function getRollingWindowEndDate({ startDate, daysNeeded, allDatesWithBookabilityStatus, countNonBusinessDays, }: {
    /**
     * It should be provided in the same utcOffset as the dates in `allDatesWithBookabilityStatus`
     * This is because we do a lookup by day in `allDatesWithBookabilityStatus`
     */
    startDate: dayjs.Dayjs;
    daysNeeded: number;
    allDatesWithBookabilityStatus: Record<string, {
        isBookable: boolean;
    }>;
    countNonBusinessDays: boolean | null;
}): dayjs.Dayjs;
/**
 * To be used when we work on Timeslots(and not Dates) to check boundaries
 * It ensures that the time isn't in the past and also checks if the time is within the minimum booking notice.
 */
export declare function isTimeOutOfBounds({ time, minimumBookingNotice, }: {
    time: dayjs.ConfigType;
    minimumBookingNotice?: number;
}): boolean;
type PeriodLimits = {
    rollingEndDay: dayjs.Dayjs | null;
    rangeStartDay: dayjs.Dayjs | null;
    rangeEndDay: dayjs.Dayjs | null;
};
/**
 * To be used when we work on just Dates(and not specific timeslots) to check boundaries
 * e.g. It checks for Future Limits which operate on dates and not times.
 */
export declare function isDateOutOfBounds({ dateString, periodLimits, }: {
    dateString: dayjs.ConfigType;
    periodLimits: PeriodLimits;
    _skipRollingWindowCheck?: boolean;
}): boolean;
export default function isOutOfBounds(time: dayjs.ConfigType, { periodType, periodDays, periodCountCalendarDays, periodStartDate, periodEndDate, utcOffset, }: Pick<EventType, "periodType" | "periodDays" | "periodCountCalendarDays" | "periodStartDate" | "periodEndDate"> & {
    utcOffset: number;
}, minimumBookingNotice?: number): boolean;
export {};
//# sourceMappingURL=isOutOfBounds.d.ts.map