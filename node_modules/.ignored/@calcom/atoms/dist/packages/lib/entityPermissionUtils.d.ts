import type { Membership } from '../prisma/client';
import { MembershipRole } from '../prisma/enums';
export declare const enum ENTITY_PERMISSION_LEVEL {
    NONE = 0,
    USER_ONLY_WRITE = 1,
    TEAM_READ_ONLY = 2,
    TEAM_WRITE = 3
}
export declare function canEditEntity(entity: Parameters<typeof getEntityPermissionLevel>[0], userId: Parameters<typeof getEntityPermissionLevel>[1]): boolean;
export declare function getEntityPermissionLevel(entity: {
    userId: number | null;
    team: {
        members: Membership[];
    } | null;
}, userId: number): ENTITY_PERMISSION_LEVEL;
export declare function canCreateEntity({ targetTeamId, userId, }: {
    targetTeamId: number | null | undefined;
    userId: number;
}): Promise<boolean>;
export declare function withRoleCanCreateEntity(role: MembershipRole): boolean;
/**
 * Whenever the entity is fetched this clause should be there to ensure that
 * 1. No item that doesn't belong to the user or the team is fetched
 * Having just a reusable where allows it to be used with different types of prisma queries.
 */
export declare const entityPrismaWhereClause: ({ userId }: {
    userId: number;
}) => {
    OR: ({
        userId: number;
        team?: undefined;
    } | {
        team: {
            members: {
                some: {
                    userId: number;
                    accepted: boolean;
                };
            };
        };
        userId?: undefined;
    })[];
};
/**
 * It returns true if the two entities are created for the same team or same user.
 */
export declare const areTheySiblingEntitites: ({ entity1, entity2, }: {
    entity1: {
        teamId: number | null;
        userId: number | null;
    };
    entity2: {
        teamId: number | null;
        userId: number | null;
    };
}) => boolean;
//# sourceMappingURL=entityPermissionUtils.d.ts.map