import { Prisma } from '../../../prisma-client';
import type { z } from "zod";
import { teamMetadataSchema } from '../../../prisma/zod-utils';
type TeamGetPayloadWithParsedMetadata<TeamSelect extends Prisma.TeamSelect> = (Omit<Prisma.TeamGetPayload<{
    select: TeamSelect;
}>, "metadata" | "isOrganization"> & {
    metadata: z.infer<typeof teamMetadataSchema>;
    isOrganization: boolean;
}) | null;
type GetTeamOrOrgArg<TeamSelect extends Prisma.TeamSelect> = {
    lookupBy: ({
        id: number;
    } | {
        slug: string;
    }) & {
        havingMemberWithId?: number;
    };
    /**
     * If we are fetching a team, this is the slug of the organization that the team belongs to.
     */
    forOrgWithSlug: string | null;
    /**
     * If true, means that we need to fetch an organization with the given slug. Otherwise, we need to fetch a team with the given slug.
     */
    isOrg: boolean;
    teamSelect: TeamSelect;
};
export declare function getTeam<TeamSelect extends Prisma.TeamSelect>({ lookupBy, forOrgWithSlug: forOrgWithSlug, teamSelect, }: Omit<GetTeamOrOrgArg<TeamSelect>, "isOrg">): Promise<TeamGetPayloadWithParsedMetadata<TeamSelect>>;
export declare function getOrg<TeamSelect extends Prisma.TeamSelect>({ lookupBy, forOrgWithSlug: forOrgWithSlug, teamSelect, }: Omit<GetTeamOrOrgArg<TeamSelect>, "isOrg">): Promise<TeamGetPayloadWithParsedMetadata<TeamSelect>>;
export declare class TeamRepository {
    static findById({ id }: {
        id: number;
    }): Promise<(Omit<{
        name: string;
        id: number;
        metadata: Prisma.JsonValue;
        slug: string | null;
        parentId: number | null;
        logoUrl: string | null;
        isOrganization: boolean;
        organizationSettings: {
            id: number;
            isOrganizationVerified: boolean;
            isOrganizationConfigured: boolean;
            isAdminReviewed: boolean;
            orgAutoAcceptEmail: string;
            organizationId: number;
            lockEventTypeCreationForUsers: boolean;
            adminGetsNoSlotsNotification: boolean;
        } | null;
    }, "metadata"> & {
        requestedSlug: string | null;
        metadata: {
            requestedSlug: string | null;
            paymentId?: string | undefined;
            subscriptionId?: string | null | undefined;
            subscriptionItemId?: string | null | undefined;
            orgSeats?: number | null | undefined;
            orgPricePerSeat?: number | null | undefined;
            migratedToOrgFrom?: {
                teamSlug?: string | null | undefined;
                lastMigrationTime?: string | undefined;
                reverted?: boolean | undefined;
                lastRevertTime?: string | undefined;
            } | undefined;
        };
    }) | null>;
}
export {};
//# sourceMappingURL=team.d.ts.map