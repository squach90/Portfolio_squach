"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@calcom";
exports.ids = ["vendor-chunks/@calcom"];
exports.modules = {

/***/ "(ssr)/./node_modules/@calcom/embed-react/dist/Cal.es.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@calcom/embed-react/dist/Cal.es.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ hr),\n/* harmony export */   getCalApi: () => (/* binding */ Er)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst fr = \"https://app.cal.com/embed/embed.js\";\nfunction X(C = fr) {\n  (function(g, m, y) {\n    let p = function(u, d) {\n      u.q.push(d);\n    }, R = g.document;\n    g.Cal = g.Cal || function() {\n      let u = g.Cal, d = arguments;\n      if (u.loaded || (u.ns = {}, u.q = u.q || [], R.head.appendChild(R.createElement(\"script\")).src = m, u.loaded = !0), d[0] === y) {\n        const l = function() {\n          p(l, arguments);\n        }, b = d[1];\n        l.q = l.q || [], typeof b == \"string\" ? (u.ns[b] = u.ns[b] || l, p(u.ns[b], d), p(u, [\"initNamespace\", b])) : p(u, d);\n        return;\n      }\n      p(u, d);\n    };\n  })(\n    window,\n    //! Replace it with \"https://cal.com/embed.js\" or the URL where you have embed.js installed\n    C,\n    \"init\"\n  );\n  /*!  Copying ends here. */\n  return window.Cal;\n}\nX.toString();\nfunction cr(C) {\n  const [g, m] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    m(() => X(C));\n  }, []), g;\n}\nvar H = { exports: {} }, A = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Te;\nfunction dr() {\n  if (Te)\n    return A;\n  Te = 1;\n  var C = react__WEBPACK_IMPORTED_MODULE_0__, g = Symbol.for(\"react.element\"), m = Symbol.for(\"react.fragment\"), y = Object.prototype.hasOwnProperty, p = C.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, R = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function u(d, l, b) {\n    var f, _ = {}, w = null, $ = null;\n    b !== void 0 && (w = \"\" + b), l.key !== void 0 && (w = \"\" + l.key), l.ref !== void 0 && ($ = l.ref);\n    for (f in l)\n      y.call(l, f) && !R.hasOwnProperty(f) && (_[f] = l[f]);\n    if (d && d.defaultProps)\n      for (f in l = d.defaultProps, l)\n        _[f] === void 0 && (_[f] = l[f]);\n    return { $$typeof: g, type: d, key: w, ref: $, props: _, _owner: p.current };\n  }\n  return A.Fragment = m, A.jsx = u, A.jsxs = u, A;\n}\nvar I = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar we;\nfunction vr() {\n  return we || (we = 1,  true && function() {\n    var C = react__WEBPACK_IMPORTED_MODULE_0__, g = Symbol.for(\"react.element\"), m = Symbol.for(\"react.portal\"), y = Symbol.for(\"react.fragment\"), p = Symbol.for(\"react.strict_mode\"), R = Symbol.for(\"react.profiler\"), u = Symbol.for(\"react.provider\"), d = Symbol.for(\"react.context\"), l = Symbol.for(\"react.forward_ref\"), b = Symbol.for(\"react.suspense\"), f = Symbol.for(\"react.suspense_list\"), _ = Symbol.for(\"react.memo\"), w = Symbol.for(\"react.lazy\"), $ = Symbol.for(\"react.offscreen\"), Z = Symbol.iterator, Pe = \"@@iterator\";\n    function xe(e) {\n      if (e === null || typeof e != \"object\")\n        return null;\n      var r = Z && e[Z] || e[Pe];\n      return typeof r == \"function\" ? r : null;\n    }\n    var x = C.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function h(e) {\n      {\n        for (var r = arguments.length, t = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)\n          t[n - 1] = arguments[n];\n        je(\"error\", e, t);\n      }\n    }\n    function je(e, r, t) {\n      {\n        var n = x.ReactDebugCurrentFrame, o = n.getStackAddendum();\n        o !== \"\" && (r += \"%s\", t = t.concat([o]));\n        var s = t.map(function(i) {\n          return String(i);\n        });\n        s.unshift(\"Warning: \" + r), Function.prototype.apply.call(console[e], console, s);\n      }\n    }\n    var ke = !1, De = !1, Fe = !1, Ae = !1, Ie = !1, Q;\n    Q = Symbol.for(\"react.module.reference\");\n    function $e(e) {\n      return !!(typeof e == \"string\" || typeof e == \"function\" || e === y || e === R || Ie || e === p || e === b || e === f || Ae || e === $ || ke || De || Fe || typeof e == \"object\" && e !== null && (e.$$typeof === w || e.$$typeof === _ || e.$$typeof === u || e.$$typeof === d || e.$$typeof === l || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      e.$$typeof === Q || e.getModuleId !== void 0));\n    }\n    function We(e, r, t) {\n      var n = e.displayName;\n      if (n)\n        return n;\n      var o = r.displayName || r.name || \"\";\n      return o !== \"\" ? t + \"(\" + o + \")\" : t;\n    }\n    function ee(e) {\n      return e.displayName || \"Context\";\n    }\n    function O(e) {\n      if (e == null)\n        return null;\n      if (typeof e.tag == \"number\" && h(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof e == \"function\")\n        return e.displayName || e.name || null;\n      if (typeof e == \"string\")\n        return e;\n      switch (e) {\n        case y:\n          return \"Fragment\";\n        case m:\n          return \"Portal\";\n        case R:\n          return \"Profiler\";\n        case p:\n          return \"StrictMode\";\n        case b:\n          return \"Suspense\";\n        case f:\n          return \"SuspenseList\";\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case d:\n            var r = e;\n            return ee(r) + \".Consumer\";\n          case u:\n            var t = e;\n            return ee(t._context) + \".Provider\";\n          case l:\n            return We(e, e.render, \"ForwardRef\");\n          case _:\n            var n = e.displayName || null;\n            return n !== null ? n : O(e.type) || \"Memo\";\n          case w: {\n            var o = e, s = o._payload, i = o._init;\n            try {\n              return O(i(s));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var P = Object.assign, D = 0, re, te, ne, ae, ie, oe, ue;\n    function se() {\n    }\n    se.__reactDisabledLog = !0;\n    function Ye() {\n      {\n        if (D === 0) {\n          re = console.log, te = console.info, ne = console.warn, ae = console.error, ie = console.group, oe = console.groupCollapsed, ue = console.groupEnd;\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            value: se,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: e,\n            log: e,\n            warn: e,\n            error: e,\n            group: e,\n            groupCollapsed: e,\n            groupEnd: e\n          });\n        }\n        D++;\n      }\n    }\n    function Le() {\n      {\n        if (D--, D === 0) {\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: P({}, e, {\n              value: re\n            }),\n            info: P({}, e, {\n              value: te\n            }),\n            warn: P({}, e, {\n              value: ne\n            }),\n            error: P({}, e, {\n              value: ae\n            }),\n            group: P({}, e, {\n              value: ie\n            }),\n            groupCollapsed: P({}, e, {\n              value: oe\n            }),\n            groupEnd: P({}, e, {\n              value: ue\n            })\n          });\n        }\n        D < 0 && h(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var V = x.ReactCurrentDispatcher, M;\n    function W(e, r, t) {\n      {\n        if (M === void 0)\n          try {\n            throw Error();\n          } catch (o) {\n            var n = o.stack.trim().match(/\\n( *(at )?)/);\n            M = n && n[1] || \"\";\n          }\n        return `\n` + M + e;\n      }\n    }\n    var q = !1, Y;\n    {\n      var Ne = typeof WeakMap == \"function\" ? WeakMap : Map;\n      Y = new Ne();\n    }\n    function le(e, r) {\n      if (!e || q)\n        return \"\";\n      {\n        var t = Y.get(e);\n        if (t !== void 0)\n          return t;\n      }\n      var n;\n      q = !0;\n      var o = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var s;\n      s = V.current, V.current = null, Ye();\n      try {\n        if (r) {\n          var i = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(i.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(i, []);\n            } catch (S) {\n              n = S;\n            }\n            Reflect.construct(e, [], i);\n          } else {\n            try {\n              i.call();\n            } catch (S) {\n              n = S;\n            }\n            e.call(i.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (S) {\n            n = S;\n          }\n          e();\n        }\n      } catch (S) {\n        if (S && n && typeof S.stack == \"string\") {\n          for (var a = S.stack.split(`\n`), E = n.stack.split(`\n`), c = a.length - 1, v = E.length - 1; c >= 1 && v >= 0 && a[c] !== E[v]; )\n            v--;\n          for (; c >= 1 && v >= 0; c--, v--)\n            if (a[c] !== E[v]) {\n              if (c !== 1 || v !== 1)\n                do\n                  if (c--, v--, v < 0 || a[c] !== E[v]) {\n                    var T = `\n` + a[c].replace(\" at new \", \" at \");\n                    return e.displayName && T.includes(\"<anonymous>\") && (T = T.replace(\"<anonymous>\", e.displayName)), typeof e == \"function\" && Y.set(e, T), T;\n                  }\n                while (c >= 1 && v >= 0);\n              break;\n            }\n        }\n      } finally {\n        q = !1, V.current = s, Le(), Error.prepareStackTrace = o;\n      }\n      var k = e ? e.displayName || e.name : \"\", _e = k ? W(k) : \"\";\n      return typeof e == \"function\" && Y.set(e, _e), _e;\n    }\n    function Ue(e, r, t) {\n      return le(e, !1);\n    }\n    function Ve(e) {\n      var r = e.prototype;\n      return !!(r && r.isReactComponent);\n    }\n    function L(e, r, t) {\n      if (e == null)\n        return \"\";\n      if (typeof e == \"function\")\n        return le(e, Ve(e));\n      if (typeof e == \"string\")\n        return W(e);\n      switch (e) {\n        case b:\n          return W(\"Suspense\");\n        case f:\n          return W(\"SuspenseList\");\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case l:\n            return Ue(e.render);\n          case _:\n            return L(e.type, r, t);\n          case w: {\n            var n = e, o = n._payload, s = n._init;\n            try {\n              return L(s(o), r, t);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var N = Object.prototype.hasOwnProperty, fe = {}, ce = x.ReactDebugCurrentFrame;\n    function U(e) {\n      if (e) {\n        var r = e._owner, t = L(e.type, e._source, r ? r.type : null);\n        ce.setExtraStackFrame(t);\n      } else\n        ce.setExtraStackFrame(null);\n    }\n    function Me(e, r, t, n, o) {\n      {\n        var s = Function.call.bind(N);\n        for (var i in e)\n          if (s(e, i)) {\n            var a = void 0;\n            try {\n              if (typeof e[i] != \"function\") {\n                var E = Error((n || \"React class\") + \": \" + t + \" type `\" + i + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof e[i] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw E.name = \"Invariant Violation\", E;\n              }\n              a = e[i](r, i, n, t, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (c) {\n              a = c;\n            }\n            a && !(a instanceof Error) && (U(o), h(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", n || \"React class\", t, i, typeof a), U(null)), a instanceof Error && !(a.message in fe) && (fe[a.message] = !0, U(o), h(\"Failed %s type: %s\", t, a.message), U(null));\n          }\n      }\n    }\n    var qe = Array.isArray;\n    function B(e) {\n      return qe(e);\n    }\n    function Be(e) {\n      {\n        var r = typeof Symbol == \"function\" && Symbol.toStringTag, t = r && e[Symbol.toStringTag] || e.constructor.name || \"Object\";\n        return t;\n      }\n    }\n    function Je(e) {\n      try {\n        return de(e), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function de(e) {\n      return \"\" + e;\n    }\n    function ve(e) {\n      if (Je(e))\n        return h(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", Be(e)), de(e);\n    }\n    var F = x.ReactCurrentOwner, Ge = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, pe, ge, J;\n    J = {};\n    function ze(e) {\n      if (N.call(e, \"ref\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"ref\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.ref !== void 0;\n    }\n    function Ke(e) {\n      if (N.call(e, \"key\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"key\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.key !== void 0;\n    }\n    function He(e, r) {\n      if (typeof e.ref == \"string\" && F.current && r && F.current.stateNode !== r) {\n        var t = O(F.current.type);\n        J[t] || (h('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', O(F.current.type), e.ref), J[t] = !0);\n      }\n    }\n    function Xe(e, r) {\n      {\n        var t = function() {\n          pe || (pe = !0, h(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"key\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    function Ze(e, r) {\n      {\n        var t = function() {\n          ge || (ge = !0, h(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"ref\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    var Qe = function(e, r, t, n, o, s, i) {\n      var a = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: g,\n        // Built-in properties that belong on the element\n        type: e,\n        key: r,\n        ref: t,\n        props: i,\n        // Record the component responsible for creating this element.\n        _owner: s\n      };\n      return a._store = {}, Object.defineProperty(a._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(a, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: n\n      }), Object.defineProperty(a, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: o\n      }), Object.freeze && (Object.freeze(a.props), Object.freeze(a)), a;\n    };\n    function er(e, r, t, n, o) {\n      {\n        var s, i = {}, a = null, E = null;\n        t !== void 0 && (ve(t), a = \"\" + t), Ke(r) && (ve(r.key), a = \"\" + r.key), ze(r) && (E = r.ref, He(r, o));\n        for (s in r)\n          N.call(r, s) && !Ge.hasOwnProperty(s) && (i[s] = r[s]);\n        if (e && e.defaultProps) {\n          var c = e.defaultProps;\n          for (s in c)\n            i[s] === void 0 && (i[s] = c[s]);\n        }\n        if (a || E) {\n          var v = typeof e == \"function\" ? e.displayName || e.name || \"Unknown\" : e;\n          a && Xe(i, v), E && Ze(i, v);\n        }\n        return Qe(e, a, E, o, n, F.current, i);\n      }\n    }\n    var G = x.ReactCurrentOwner, me = x.ReactDebugCurrentFrame;\n    function j(e) {\n      if (e) {\n        var r = e._owner, t = L(e.type, e._source, r ? r.type : null);\n        me.setExtraStackFrame(t);\n      } else\n        me.setExtraStackFrame(null);\n    }\n    var z;\n    z = !1;\n    function K(e) {\n      return typeof e == \"object\" && e !== null && e.$$typeof === g;\n    }\n    function be() {\n      {\n        if (G.current) {\n          var e = O(G.current.type);\n          if (e)\n            return `\n\nCheck the render method of \\`` + e + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function rr(e) {\n      {\n        if (e !== void 0) {\n          var r = e.fileName.replace(/^.*[\\\\\\/]/, \"\"), t = e.lineNumber;\n          return `\n\nCheck your code at ` + r + \":\" + t + \".\";\n        }\n        return \"\";\n      }\n    }\n    var he = {};\n    function tr(e) {\n      {\n        var r = be();\n        if (!r) {\n          var t = typeof e == \"string\" ? e : e.displayName || e.name;\n          t && (r = `\n\nCheck the top-level render call using <` + t + \">.\");\n        }\n        return r;\n      }\n    }\n    function Ee(e, r) {\n      {\n        if (!e._store || e._store.validated || e.key != null)\n          return;\n        e._store.validated = !0;\n        var t = tr(r);\n        if (he[t])\n          return;\n        he[t] = !0;\n        var n = \"\";\n        e && e._owner && e._owner !== G.current && (n = \" It was passed a child from \" + O(e._owner.type) + \".\"), j(e), h('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', t, n), j(null);\n      }\n    }\n    function ye(e, r) {\n      {\n        if (typeof e != \"object\")\n          return;\n        if (B(e))\n          for (var t = 0; t < e.length; t++) {\n            var n = e[t];\n            K(n) && Ee(n, r);\n          }\n        else if (K(e))\n          e._store && (e._store.validated = !0);\n        else if (e) {\n          var o = xe(e);\n          if (typeof o == \"function\" && o !== e.entries)\n            for (var s = o.call(e), i; !(i = s.next()).done; )\n              K(i.value) && Ee(i.value, r);\n        }\n      }\n    }\n    function nr(e) {\n      {\n        var r = e.type;\n        if (r == null || typeof r == \"string\")\n          return;\n        var t;\n        if (typeof r == \"function\")\n          t = r.propTypes;\n        else if (typeof r == \"object\" && (r.$$typeof === l || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        r.$$typeof === _))\n          t = r.propTypes;\n        else\n          return;\n        if (t) {\n          var n = O(r);\n          Me(t, e.props, \"prop\", n, e);\n        } else if (r.PropTypes !== void 0 && !z) {\n          z = !0;\n          var o = O(r);\n          h(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", o || \"Unknown\");\n        }\n        typeof r.getDefaultProps == \"function\" && !r.getDefaultProps.isReactClassApproved && h(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function ar(e) {\n      {\n        for (var r = Object.keys(e.props), t = 0; t < r.length; t++) {\n          var n = r[t];\n          if (n !== \"children\" && n !== \"key\") {\n            j(e), h(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", n), j(null);\n            break;\n          }\n        }\n        e.ref !== null && (j(e), h(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), j(null));\n      }\n    }\n    function Re(e, r, t, n, o, s) {\n      {\n        var i = $e(e);\n        if (!i) {\n          var a = \"\";\n          (e === void 0 || typeof e == \"object\" && e !== null && Object.keys(e).length === 0) && (a += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var E = rr(o);\n          E ? a += E : a += be();\n          var c;\n          e === null ? c = \"null\" : B(e) ? c = \"array\" : e !== void 0 && e.$$typeof === g ? (c = \"<\" + (O(e.type) || \"Unknown\") + \" />\", a = \" Did you accidentally export a JSX literal instead of a component?\") : c = typeof e, h(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", c, a);\n        }\n        var v = er(e, r, t, o, s);\n        if (v == null)\n          return v;\n        if (i) {\n          var T = r.children;\n          if (T !== void 0)\n            if (n)\n              if (B(T)) {\n                for (var k = 0; k < T.length; k++)\n                  ye(T[k], e);\n                Object.freeze && Object.freeze(T);\n              } else\n                h(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              ye(T, e);\n        }\n        return e === y ? ar(v) : nr(v), v;\n      }\n    }\n    function ir(e, r, t) {\n      return Re(e, r, t, !0);\n    }\n    function or(e, r, t) {\n      return Re(e, r, t, !1);\n    }\n    var ur = or, sr = ir;\n    I.Fragment = y, I.jsx = ur, I.jsxs = sr;\n  }()), I;\n}\n false ? 0 : H.exports = vr();\nvar pr = H.exports;\nconst gr = pr.jsx, mr = function(g) {\n  const {\n    calLink: m,\n    calOrigin: y,\n    namespace: p = \"\",\n    config: R,\n    initConfig: u = {},\n    embedJsUrl: d,\n    ...l\n  } = g;\n  if (!m)\n    throw new Error(\"calLink is required\");\n  const b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), f = cr(d), _ = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!f || b.current || !_.current)\n      return;\n    b.current = !0;\n    const w = _.current;\n    p ? (f(\"init\", p, {\n      ...u,\n      origin: y\n    }), f.ns[p](\"inline\", {\n      elementOrSelector: w,\n      calLink: m,\n      config: R\n    })) : (f(\"init\", {\n      ...u,\n      origin: y\n    }), f(\"inline\", {\n      elementOrSelector: w,\n      calLink: m,\n      config: R\n    }));\n  }, [f, m, R, p, y, u]), f ? /* @__PURE__ */ gr(\"div\", {\n    ref: _,\n    ...l\n  }) : null;\n}, hr = mr;\nfunction Er(C) {\n  const g = typeof C == \"string\" ? { embedJsUrl: C } : C ?? {}, { namespace: m = \"\", embedJsUrl: y } = g;\n  return new Promise(function p(R) {\n    const u = X(y);\n    u(\"init\", m);\n    const d = m ? u.ns[m] : u;\n    if (!d) {\n      setTimeout(() => {\n        p(R);\n      }, 50);\n      return;\n    }\n    R(d);\n  });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhbGNvbS9lbWJlZC1yZWFjdC9kaXN0L0NhbC5lcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0NBQUU7QUFDbkIsU0FBUyxnREFBRTtBQUNYO0FBQ0EsR0FBRztBQUNIO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtDQUFFLDRMQUE0TDtBQUN4TTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQXFDO0FBQzdELFlBQVksa0NBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsT0FBTztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiLGdDQUFnQztBQUNoQztBQUNBLGFBQWE7QUFDYiwwQkFBMEI7QUFDMUI7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQ0FBbUM7QUFDM0U7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE1BQXFDLEdBQUcsQ0FBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsWUFBWSw2Q0FBRSxxQkFBcUIsNkNBQUU7QUFDckMsU0FBUyxnREFBRTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxxQ0FBcUMsZ0JBQWdCLFNBQVMsSUFBSSxtQ0FBbUM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQGNhbGNvbS9lbWJlZC1yZWFjdC9kaXN0L0NhbC5lcy5tanM/ZDU4MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgT2UsIHsgdXNlU3RhdGUgYXMgbHIsIHVzZUVmZmVjdCBhcyBTZSwgdXNlUmVmIGFzIENlIH0gZnJvbSBcInJlYWN0XCI7XG5jb25zdCBmciA9IFwiaHR0cHM6Ly9hcHAuY2FsLmNvbS9lbWJlZC9lbWJlZC5qc1wiO1xuZnVuY3Rpb24gWChDID0gZnIpIHtcbiAgKGZ1bmN0aW9uKGcsIG0sIHkpIHtcbiAgICBsZXQgcCA9IGZ1bmN0aW9uKHUsIGQpIHtcbiAgICAgIHUucS5wdXNoKGQpO1xuICAgIH0sIFIgPSBnLmRvY3VtZW50O1xuICAgIGcuQ2FsID0gZy5DYWwgfHwgZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgdSA9IGcuQ2FsLCBkID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHUubG9hZGVkIHx8ICh1Lm5zID0ge30sIHUucSA9IHUucSB8fCBbXSwgUi5oZWFkLmFwcGVuZENoaWxkKFIuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkuc3JjID0gbSwgdS5sb2FkZWQgPSAhMCksIGRbMF0gPT09IHkpIHtcbiAgICAgICAgY29uc3QgbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHAobCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgYiA9IGRbMV07XG4gICAgICAgIGwucSA9IGwucSB8fCBbXSwgdHlwZW9mIGIgPT0gXCJzdHJpbmdcIiA/ICh1Lm5zW2JdID0gdS5uc1tiXSB8fCBsLCBwKHUubnNbYl0sIGQpLCBwKHUsIFtcImluaXROYW1lc3BhY2VcIiwgYl0pKSA6IHAodSwgZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHAodSwgZCk7XG4gICAgfTtcbiAgfSkoXG4gICAgd2luZG93LFxuICAgIC8vISBSZXBsYWNlIGl0IHdpdGggXCJodHRwczovL2NhbC5jb20vZW1iZWQuanNcIiBvciB0aGUgVVJMIHdoZXJlIHlvdSBoYXZlIGVtYmVkLmpzIGluc3RhbGxlZFxuICAgIEMsXG4gICAgXCJpbml0XCJcbiAgKTtcbiAgLyohICBDb3B5aW5nIGVuZHMgaGVyZS4gKi9cbiAgcmV0dXJuIHdpbmRvdy5DYWw7XG59XG5YLnRvU3RyaW5nKCk7XG5mdW5jdGlvbiBjcihDKSB7XG4gIGNvbnN0IFtnLCBtXSA9IGxyKCk7XG4gIHJldHVybiBTZSgoKSA9PiB7XG4gICAgbSgoKSA9PiBYKEMpKTtcbiAgfSwgW10pLCBnO1xufVxudmFyIEggPSB7IGV4cG9ydHM6IHt9IH0sIEEgPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBUZTtcbmZ1bmN0aW9uIGRyKCkge1xuICBpZiAoVGUpXG4gICAgcmV0dXJuIEE7XG4gIFRlID0gMTtcbiAgdmFyIEMgPSBPZSwgZyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCBtID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCB5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgcCA9IEMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIsIFIgPSB7IGtleTogITAsIHJlZjogITAsIF9fc2VsZjogITAsIF9fc291cmNlOiAhMCB9O1xuICBmdW5jdGlvbiB1KGQsIGwsIGIpIHtcbiAgICB2YXIgZiwgXyA9IHt9LCB3ID0gbnVsbCwgJCA9IG51bGw7XG4gICAgYiAhPT0gdm9pZCAwICYmICh3ID0gXCJcIiArIGIpLCBsLmtleSAhPT0gdm9pZCAwICYmICh3ID0gXCJcIiArIGwua2V5KSwgbC5yZWYgIT09IHZvaWQgMCAmJiAoJCA9IGwucmVmKTtcbiAgICBmb3IgKGYgaW4gbClcbiAgICAgIHkuY2FsbChsLCBmKSAmJiAhUi5oYXNPd25Qcm9wZXJ0eShmKSAmJiAoX1tmXSA9IGxbZl0pO1xuICAgIGlmIChkICYmIGQuZGVmYXVsdFByb3BzKVxuICAgICAgZm9yIChmIGluIGwgPSBkLmRlZmF1bHRQcm9wcywgbClcbiAgICAgICAgX1tmXSA9PT0gdm9pZCAwICYmIChfW2ZdID0gbFtmXSk7XG4gICAgcmV0dXJuIHsgJCR0eXBlb2Y6IGcsIHR5cGU6IGQsIGtleTogdywgcmVmOiAkLCBwcm9wczogXywgX293bmVyOiBwLmN1cnJlbnQgfTtcbiAgfVxuICByZXR1cm4gQS5GcmFnbWVudCA9IG0sIEEuanN4ID0gdSwgQS5qc3hzID0gdSwgQTtcbn1cbnZhciBJID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgd2U7XG5mdW5jdGlvbiB2cigpIHtcbiAgcmV0dXJuIHdlIHx8ICh3ZSA9IDEsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmdW5jdGlvbigpIHtcbiAgICB2YXIgQyA9IE9lLCBnID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIG0gPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCB5ID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBwID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLCBSID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLCB1ID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLCBkID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksIGwgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksIGIgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksIGYgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSwgXyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLCB3ID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksICQgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLCBaID0gU3ltYm9sLml0ZXJhdG9yLCBQZSA9IFwiQEBpdGVyYXRvclwiO1xuICAgIGZ1bmN0aW9uIHhlKGUpIHtcbiAgICAgIGlmIChlID09PSBudWxsIHx8IHR5cGVvZiBlICE9IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIHIgPSBaICYmIGVbWl0gfHwgZVtQZV07XG4gICAgICByZXR1cm4gdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiID8gciA6IG51bGw7XG4gICAgfVxuICAgIHZhciB4ID0gQy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgICBmdW5jdGlvbiBoKGUpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkociA+IDEgPyByIC0gMSA6IDApLCBuID0gMTsgbiA8IHI7IG4rKylcbiAgICAgICAgICB0W24gLSAxXSA9IGFyZ3VtZW50c1tuXTtcbiAgICAgICAgamUoXCJlcnJvclwiLCBlLCB0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gamUoZSwgciwgdCkge1xuICAgICAge1xuICAgICAgICB2YXIgbiA9IHguUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSwgbyA9IG4uZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgICAgICBvICE9PSBcIlwiICYmIChyICs9IFwiJXNcIiwgdCA9IHQuY29uY2F0KFtvXSkpO1xuICAgICAgICB2YXIgcyA9IHQubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKGkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcy51bnNoaWZ0KFwiV2FybmluZzogXCIgKyByKSwgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtlXSwgY29uc29sZSwgcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBrZSA9ICExLCBEZSA9ICExLCBGZSA9ICExLCBBZSA9ICExLCBJZSA9ICExLCBRO1xuICAgIFEgPSBTeW1ib2wuZm9yKFwicmVhY3QubW9kdWxlLnJlZmVyZW5jZVwiKTtcbiAgICBmdW5jdGlvbiAkZShlKSB7XG4gICAgICByZXR1cm4gISEodHlwZW9mIGUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgfHwgZSA9PT0geSB8fCBlID09PSBSIHx8IEllIHx8IGUgPT09IHAgfHwgZSA9PT0gYiB8fCBlID09PSBmIHx8IEFlIHx8IGUgPT09ICQgfHwga2UgfHwgRGUgfHwgRmUgfHwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBlICE9PSBudWxsICYmIChlLiQkdHlwZW9mID09PSB3IHx8IGUuJCR0eXBlb2YgPT09IF8gfHwgZS4kJHR5cGVvZiA9PT0gdSB8fCBlLiQkdHlwZW9mID09PSBkIHx8IGUuJCR0eXBlb2YgPT09IGwgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgICAvLyB3aXRoLlxuICAgICAgZS4kJHR5cGVvZiA9PT0gUSB8fCBlLmdldE1vZHVsZUlkICE9PSB2b2lkIDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV2UoZSwgciwgdCkge1xuICAgICAgdmFyIG4gPSBlLmRpc3BsYXlOYW1lO1xuICAgICAgaWYgKG4pXG4gICAgICAgIHJldHVybiBuO1xuICAgICAgdmFyIG8gPSByLmRpc3BsYXlOYW1lIHx8IHIubmFtZSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIG8gIT09IFwiXCIgPyB0ICsgXCIoXCIgKyBvICsgXCIpXCIgOiB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlZShlKSB7XG4gICAgICByZXR1cm4gZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gTyhlKSB7XG4gICAgICBpZiAoZSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgZS50YWcgPT0gXCJudW1iZXJcIiAmJiBoKFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiksIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSB5OlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgbTpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBSOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgcDpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgYjpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIGY6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBkOlxuICAgICAgICAgICAgdmFyIHIgPSBlO1xuICAgICAgICAgICAgcmV0dXJuIGVlKHIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIHU6XG4gICAgICAgICAgICB2YXIgdCA9IGU7XG4gICAgICAgICAgICByZXR1cm4gZWUodC5fY29udGV4dCkgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgbDpcbiAgICAgICAgICAgIHJldHVybiBXZShlLCBlLnJlbmRlciwgXCJGb3J3YXJkUmVmXCIpO1xuICAgICAgICAgIGNhc2UgXzpcbiAgICAgICAgICAgIHZhciBuID0gZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG4gIT09IG51bGwgPyBuIDogTyhlLnR5cGUpIHx8IFwiTWVtb1wiO1xuICAgICAgICAgIGNhc2Ugdzoge1xuICAgICAgICAgICAgdmFyIG8gPSBlLCBzID0gby5fcGF5bG9hZCwgaSA9IG8uX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gTyhpKHMpKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgUCA9IE9iamVjdC5hc3NpZ24sIEQgPSAwLCByZSwgdGUsIG5lLCBhZSwgaWUsIG9lLCB1ZTtcbiAgICBmdW5jdGlvbiBzZSgpIHtcbiAgICB9XG4gICAgc2UuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgZnVuY3Rpb24gWWUoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChEID09PSAwKSB7XG4gICAgICAgICAgcmUgPSBjb25zb2xlLmxvZywgdGUgPSBjb25zb2xlLmluZm8sIG5lID0gY29uc29sZS53YXJuLCBhZSA9IGNvbnNvbGUuZXJyb3IsIGllID0gY29uc29sZS5ncm91cCwgb2UgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkLCB1ZSA9IGNvbnNvbGUuZ3JvdXBFbmQ7XG4gICAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB2YWx1ZTogc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGluZm86IGUsXG4gICAgICAgICAgICBsb2c6IGUsXG4gICAgICAgICAgICB3YXJuOiBlLFxuICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICBncm91cDogZSxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBlLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBEKys7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIExlKCkge1xuICAgICAge1xuICAgICAgICBpZiAoRC0tLCBEID09PSAwKSB7XG4gICAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGxvZzogUCh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogcmVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW5mbzogUCh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogdGVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2FybjogUCh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogbmVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXJyb3I6IFAoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGFlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwOiBQKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBpZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogUCh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogb2VcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IFAoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHVlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIEQgPCAwICYmIGgoXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgViA9IHguUmVhY3RDdXJyZW50RGlzcGF0Y2hlciwgTTtcbiAgICBmdW5jdGlvbiBXKGUsIHIsIHQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKE0gPT09IHZvaWQgMClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgICAgICB2YXIgbiA9IG8uc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgICBNID0gbiAmJiBuWzFdIHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFxuYCArIE0gKyBlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcSA9ICExLCBZO1xuICAgIHtcbiAgICAgIHZhciBOZSA9IHR5cGVvZiBXZWFrTWFwID09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBNYXA7XG4gICAgICBZID0gbmV3IE5lKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxlKGUsIHIpIHtcbiAgICAgIGlmICghZSB8fCBxKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIHtcbiAgICAgICAgdmFyIHQgPSBZLmdldChlKTtcbiAgICAgICAgaWYgKHQgIT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICAgIHZhciBuO1xuICAgICAgcSA9ICEwO1xuICAgICAgdmFyIG8gPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIHM7XG4gICAgICBzID0gVi5jdXJyZW50LCBWLmN1cnJlbnQgPSBudWxsLCBZZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICB2YXIgaSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkoaS5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgdHlwZW9mIFJlZmxlY3QgPT0gXCJvYmplY3RcIiAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoaSwgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoUykge1xuICAgICAgICAgICAgICBuID0gUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGUsIFtdLCBpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaS5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChTKSB7XG4gICAgICAgICAgICAgIG4gPSBTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5jYWxsKGkucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoUykge1xuICAgICAgICAgICAgbiA9IFM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGUoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoUykge1xuICAgICAgICBpZiAoUyAmJiBuICYmIHR5cGVvZiBTLnN0YWNrID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciBhID0gUy5zdGFjay5zcGxpdChgXG5gKSwgRSA9IG4uc3RhY2suc3BsaXQoYFxuYCksIGMgPSBhLmxlbmd0aCAtIDEsIHYgPSBFLmxlbmd0aCAtIDE7IGMgPj0gMSAmJiB2ID49IDAgJiYgYVtjXSAhPT0gRVt2XTsgKVxuICAgICAgICAgICAgdi0tO1xuICAgICAgICAgIGZvciAoOyBjID49IDEgJiYgdiA+PSAwOyBjLS0sIHYtLSlcbiAgICAgICAgICAgIGlmIChhW2NdICE9PSBFW3ZdKSB7XG4gICAgICAgICAgICAgIGlmIChjICE9PSAxIHx8IHYgIT09IDEpXG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChjLS0sIHYtLSwgdiA8IDAgfHwgYVtjXSAhPT0gRVt2XSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgVCA9IGBcbmAgKyBhW2NdLnJlcGxhY2UoXCIgYXQgbmV3IFwiLCBcIiBhdCBcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmRpc3BsYXlOYW1lICYmIFQuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJiAoVCA9IFQucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGUuZGlzcGxheU5hbWUpKSwgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiICYmIFkuc2V0KGUsIFQpLCBUO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChjID49IDEgJiYgdiA+PSAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHEgPSAhMSwgVi5jdXJyZW50ID0gcywgTGUoKSwgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBvO1xuICAgICAgfVxuICAgICAgdmFyIGsgPSBlID8gZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUgOiBcIlwiLCBfZSA9IGsgPyBXKGspIDogXCJcIjtcbiAgICAgIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgWS5zZXQoZSwgX2UpLCBfZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVWUoZSwgciwgdCkge1xuICAgICAgcmV0dXJuIGxlKGUsICExKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmUoZSkge1xuICAgICAgdmFyIHIgPSBlLnByb3RvdHlwZTtcbiAgICAgIHJldHVybiAhIShyICYmIHIuaXNSZWFjdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEwoZSwgciwgdCkge1xuICAgICAgaWYgKGUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gbGUoZSwgVmUoZSkpO1xuICAgICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBXKGUpO1xuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgYjpcbiAgICAgICAgICByZXR1cm4gVyhcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIGY6XG4gICAgICAgICAgcmV0dXJuIFcoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgICAgcmV0dXJuIFVlKGUucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIF86XG4gICAgICAgICAgICByZXR1cm4gTChlLnR5cGUsIHIsIHQpO1xuICAgICAgICAgIGNhc2Ugdzoge1xuICAgICAgICAgICAgdmFyIG4gPSBlLCBvID0gbi5fcGF5bG9hZCwgcyA9IG4uX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gTChzKG8pLCByLCB0KTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciBOID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgZmUgPSB7fSwgY2UgPSB4LlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gVShlKSB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICB2YXIgciA9IGUuX293bmVyLCB0ID0gTChlLnR5cGUsIGUuX3NvdXJjZSwgciA/IHIudHlwZSA6IG51bGwpO1xuICAgICAgICBjZS5zZXRFeHRyYVN0YWNrRnJhbWUodCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgY2Uuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNZShlLCByLCB0LCBuLCBvKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE4pO1xuICAgICAgICBmb3IgKHZhciBpIGluIGUpXG4gICAgICAgICAgaWYgKHMoZSwgaSkpIHtcbiAgICAgICAgICAgIHZhciBhID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlW2ldICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBFID0gRXJyb3IoKG4gfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIHQgKyBcIiB0eXBlIGBcIiArIGkgKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgdHlwZW9mIGVbaV0gKyBcImAuVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IEUubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiLCBFO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGEgPSBlW2ldKHIsIGksIG4sIHQsIG51bGwsIFwiU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRURcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChjKSB7XG4gICAgICAgICAgICAgIGEgPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYSAmJiAhKGEgaW5zdGFuY2VvZiBFcnJvcikgJiYgKFUobyksIGgoXCIlczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciBmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCBzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuXCIsIG4gfHwgXCJSZWFjdCBjbGFzc1wiLCB0LCBpLCB0eXBlb2YgYSksIFUobnVsbCkpLCBhIGluc3RhbmNlb2YgRXJyb3IgJiYgIShhLm1lc3NhZ2UgaW4gZmUpICYmIChmZVthLm1lc3NhZ2VdID0gITAsIFUobyksIGgoXCJGYWlsZWQgJXMgdHlwZTogJXNcIiwgdCwgYS5tZXNzYWdlKSwgVShudWxsKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcWUgPSBBcnJheS5pc0FycmF5O1xuICAgIGZ1bmN0aW9uIEIoZSkge1xuICAgICAgcmV0dXJuIHFlKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBCZShlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnLCB0ID0gciAmJiBlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgZS5jb25zdHJ1Y3Rvci5uYW1lIHx8IFwiT2JqZWN0XCI7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBKZShlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGUoZSksICExO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGUoZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2ZShlKSB7XG4gICAgICBpZiAoSmUoZSkpXG4gICAgICAgIHJldHVybiBoKFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsIEJlKGUpKSwgZGUoZSk7XG4gICAgfVxuICAgIHZhciBGID0geC5SZWFjdEN1cnJlbnRPd25lciwgR2UgPSB7XG4gICAgICBrZXk6ICEwLFxuICAgICAgcmVmOiAhMCxcbiAgICAgIF9fc2VsZjogITAsXG4gICAgICBfX3NvdXJjZTogITBcbiAgICB9LCBwZSwgZ2UsIEo7XG4gICAgSiA9IHt9O1xuICAgIGZ1bmN0aW9uIHplKGUpIHtcbiAgICAgIGlmIChOLmNhbGwoZSwgXCJyZWZcIikpIHtcbiAgICAgICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIFwicmVmXCIpLmdldDtcbiAgICAgICAgaWYgKHIgJiYgci5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gZS5yZWYgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gS2UoZSkge1xuICAgICAgaWYgKE4uY2FsbChlLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAociAmJiByLmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlLmtleSAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBIZShlLCByKSB7XG4gICAgICBpZiAodHlwZW9mIGUucmVmID09IFwic3RyaW5nXCIgJiYgRi5jdXJyZW50ICYmIHIgJiYgRi5jdXJyZW50LnN0YXRlTm9kZSAhPT0gcikge1xuICAgICAgICB2YXIgdCA9IE8oRi5jdXJyZW50LnR5cGUpO1xuICAgICAgICBKW3RdIHx8IChoKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIFRoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uIFdlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiBMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgTyhGLmN1cnJlbnQudHlwZSksIGUucmVmKSwgSlt0XSA9ICEwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gWGUoZSwgcikge1xuICAgICAge1xuICAgICAgICB2YXIgdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHBlIHx8IChwZSA9ICEwLCBoKFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgcikpO1xuICAgICAgICB9O1xuICAgICAgICB0LmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImtleVwiLCB7XG4gICAgICAgICAgZ2V0OiB0LFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFplKGUsIHIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBnZSB8fCAoZ2UgPSAhMCwgaChcIiVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIHIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdC5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJyZWZcIiwge1xuICAgICAgICAgIGdldDogdCxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgUWUgPSBmdW5jdGlvbihlLCByLCB0LCBuLCBvLCBzLCBpKSB7XG4gICAgICB2YXIgYSA9IHtcbiAgICAgICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgICAgICQkdHlwZW9mOiBnLFxuICAgICAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgICAgIHR5cGU6IGUsXG4gICAgICAgIGtleTogcixcbiAgICAgICAgcmVmOiB0LFxuICAgICAgICBwcm9wczogaSxcbiAgICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgICAgX293bmVyOiBzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGEuX3N0b3JlID0ge30sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogITFcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgXCJfc2VsZlwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIHZhbHVlOiBuXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIFwiX3NvdXJjZVwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIHZhbHVlOiBvXG4gICAgICB9KSwgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZShhLnByb3BzKSwgT2JqZWN0LmZyZWV6ZShhKSksIGE7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBlcihlLCByLCB0LCBuLCBvKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBzLCBpID0ge30sIGEgPSBudWxsLCBFID0gbnVsbDtcbiAgICAgICAgdCAhPT0gdm9pZCAwICYmICh2ZSh0KSwgYSA9IFwiXCIgKyB0KSwgS2UocikgJiYgKHZlKHIua2V5KSwgYSA9IFwiXCIgKyByLmtleSksIHplKHIpICYmIChFID0gci5yZWYsIEhlKHIsIG8pKTtcbiAgICAgICAgZm9yIChzIGluIHIpXG4gICAgICAgICAgTi5jYWxsKHIsIHMpICYmICFHZS5oYXNPd25Qcm9wZXJ0eShzKSAmJiAoaVtzXSA9IHJbc10pO1xuICAgICAgICBpZiAoZSAmJiBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgICAgIHZhciBjID0gZS5kZWZhdWx0UHJvcHM7XG4gICAgICAgICAgZm9yIChzIGluIGMpXG4gICAgICAgICAgICBpW3NdID09PSB2b2lkIDAgJiYgKGlbc10gPSBjW3NdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYSB8fCBFKSB7XG4gICAgICAgICAgdmFyIHYgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSB8fCBcIlVua25vd25cIiA6IGU7XG4gICAgICAgICAgYSAmJiBYZShpLCB2KSwgRSAmJiBaZShpLCB2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUWUoZSwgYSwgRSwgbywgbiwgRi5jdXJyZW50LCBpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIEcgPSB4LlJlYWN0Q3VycmVudE93bmVyLCBtZSA9IHguUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICBmdW5jdGlvbiBqKGUpIHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIHZhciByID0gZS5fb3duZXIsIHQgPSBMKGUudHlwZSwgZS5fc291cmNlLCByID8gci50eXBlIDogbnVsbCk7XG4gICAgICAgIG1lLnNldEV4dHJhU3RhY2tGcmFtZSh0KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIHZhciB6O1xuICAgIHogPSAhMTtcbiAgICBmdW5jdGlvbiBLKGUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgIT09IG51bGwgJiYgZS4kJHR5cGVvZiA9PT0gZztcbiAgICB9XG4gICAgZnVuY3Rpb24gYmUoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChHLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgZSA9IE8oRy5jdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGlmIChlKVxuICAgICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgXFxgYCArIGUgKyBcImAuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJyKGUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciByID0gZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCBcIlwiKSwgdCA9IGUubGluZU51bWJlcjtcbiAgICAgICAgICByZXR1cm4gYFxuXG5DaGVjayB5b3VyIGNvZGUgYXQgYCArIHIgKyBcIjpcIiArIHQgKyBcIi5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGhlID0ge307XG4gICAgZnVuY3Rpb24gdHIoZSkge1xuICAgICAge1xuICAgICAgICB2YXIgciA9IGJlKCk7XG4gICAgICAgIGlmICghcikge1xuICAgICAgICAgIHZhciB0ID0gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGUgOiBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZTtcbiAgICAgICAgICB0ICYmIChyID0gYFxuXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxgICsgdCArIFwiPi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEVlKGUsIHIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFlLl9zdG9yZSB8fCBlLl9zdG9yZS52YWxpZGF0ZWQgfHwgZS5rZXkgIT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGUuX3N0b3JlLnZhbGlkYXRlZCA9ICEwO1xuICAgICAgICB2YXIgdCA9IHRyKHIpO1xuICAgICAgICBpZiAoaGVbdF0pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBoZVt0XSA9ICEwO1xuICAgICAgICB2YXIgbiA9IFwiXCI7XG4gICAgICAgIGUgJiYgZS5fb3duZXIgJiYgZS5fb3duZXIgIT09IEcuY3VycmVudCAmJiAobiA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgTyhlLl9vd25lci50eXBlKSArIFwiLlwiKSwgaihlKSwgaCgnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgdCwgbiksIGoobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHllKGUsIHIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoQihlKSlcbiAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIHZhciBuID0gZVt0XTtcbiAgICAgICAgICAgIEsobikgJiYgRWUobiwgcik7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChLKGUpKVxuICAgICAgICAgIGUuX3N0b3JlICYmIChlLl9zdG9yZS52YWxpZGF0ZWQgPSAhMCk7XG4gICAgICAgIGVsc2UgaWYgKGUpIHtcbiAgICAgICAgICB2YXIgbyA9IHhlKGUpO1xuICAgICAgICAgIGlmICh0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIgJiYgbyAhPT0gZS5lbnRyaWVzKVxuICAgICAgICAgICAgZm9yICh2YXIgcyA9IG8uY2FsbChlKSwgaTsgIShpID0gcy5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgICAgSyhpLnZhbHVlKSAmJiBFZShpLnZhbHVlLCByKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBucihlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByID0gZS50eXBlO1xuICAgICAgICBpZiAociA9PSBudWxsIHx8IHR5cGVvZiByID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgaWYgKHR5cGVvZiByID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICB0ID0gci5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiByID09IFwib2JqZWN0XCIgJiYgKHIuJCR0eXBlb2YgPT09IGwgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgICAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICAgICAgci4kJHR5cGVvZiA9PT0gXykpXG4gICAgICAgICAgdCA9IHIucHJvcFR5cGVzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgIHZhciBuID0gTyhyKTtcbiAgICAgICAgICBNZSh0LCBlLnByb3BzLCBcInByb3BcIiwgbiwgZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoci5Qcm9wVHlwZXMgIT09IHZvaWQgMCAmJiAheikge1xuICAgICAgICAgIHogPSAhMDtcbiAgICAgICAgICB2YXIgbyA9IE8ocik7XG4gICAgICAgICAgaChcIkNvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50P1wiLCBvIHx8IFwiVW5rbm93blwiKTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlb2Ygci5nZXREZWZhdWx0UHJvcHMgPT0gXCJmdW5jdGlvblwiICYmICFyLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJiBoKFwiZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzIGRlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyKGUpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgciA9IE9iamVjdC5rZXlzKGUucHJvcHMpLCB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICB2YXIgbiA9IHJbdF07XG4gICAgICAgICAgaWYgKG4gIT09IFwiY2hpbGRyZW5cIiAmJiBuICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICBqKGUpLCBoKFwiSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy5cIiwgbiksIGoobnVsbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZS5yZWYgIT09IG51bGwgJiYgKGooZSksIGgoXCJJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLlwiKSwgaihudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlKGUsIHIsIHQsIG4sIG8sIHMpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGkgPSAkZShlKTtcbiAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgdmFyIGEgPSBcIlwiO1xuICAgICAgICAgIChlID09PSB2b2lkIDAgfHwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKGUpLmxlbmd0aCA9PT0gMCkgJiYgKGEgKz0gXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiKTtcbiAgICAgICAgICB2YXIgRSA9IHJyKG8pO1xuICAgICAgICAgIEUgPyBhICs9IEUgOiBhICs9IGJlKCk7XG4gICAgICAgICAgdmFyIGM7XG4gICAgICAgICAgZSA9PT0gbnVsbCA/IGMgPSBcIm51bGxcIiA6IEIoZSkgPyBjID0gXCJhcnJheVwiIDogZSAhPT0gdm9pZCAwICYmIGUuJCR0eXBlb2YgPT09IGcgPyAoYyA9IFwiPFwiICsgKE8oZS50eXBlKSB8fCBcIlVua25vd25cIikgKyBcIiAvPlwiLCBhID0gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikgOiBjID0gdHlwZW9mIGUsIGgoXCJSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXNcIiwgYywgYSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHYgPSBlcihlLCByLCB0LCBvLCBzKTtcbiAgICAgICAgaWYgKHYgPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICB2YXIgVCA9IHIuY2hpbGRyZW47XG4gICAgICAgICAgaWYgKFQgIT09IHZvaWQgMClcbiAgICAgICAgICAgIGlmIChuKVxuICAgICAgICAgICAgICBpZiAoQihUKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgVC5sZW5ndGg7IGsrKylcbiAgICAgICAgICAgICAgICAgIHllKFRba10sIGUpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShUKTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgaChcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHllKFQsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlID09PSB5ID8gYXIodikgOiBucih2KSwgdjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXIoZSwgciwgdCkge1xuICAgICAgcmV0dXJuIFJlKGUsIHIsIHQsICEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb3IoZSwgciwgdCkge1xuICAgICAgcmV0dXJuIFJlKGUsIHIsIHQsICExKTtcbiAgICB9XG4gICAgdmFyIHVyID0gb3IsIHNyID0gaXI7XG4gICAgSS5GcmFnbWVudCA9IHksIEkuanN4ID0gdXIsIEkuanN4cyA9IHNyO1xuICB9KCkpLCBJO1xufVxucHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gSC5leHBvcnRzID0gZHIoKSA6IEguZXhwb3J0cyA9IHZyKCk7XG52YXIgcHIgPSBILmV4cG9ydHM7XG5jb25zdCBnciA9IHByLmpzeCwgbXIgPSBmdW5jdGlvbihnKSB7XG4gIGNvbnN0IHtcbiAgICBjYWxMaW5rOiBtLFxuICAgIGNhbE9yaWdpbjogeSxcbiAgICBuYW1lc3BhY2U6IHAgPSBcIlwiLFxuICAgIGNvbmZpZzogUixcbiAgICBpbml0Q29uZmlnOiB1ID0ge30sXG4gICAgZW1iZWRKc1VybDogZCxcbiAgICAuLi5sXG4gIH0gPSBnO1xuICBpZiAoIW0pXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2FsTGluayBpcyByZXF1aXJlZFwiKTtcbiAgY29uc3QgYiA9IENlKCExKSwgZiA9IGNyKGQpLCBfID0gQ2UobnVsbCk7XG4gIHJldHVybiBTZSgoKSA9PiB7XG4gICAgaWYgKCFmIHx8IGIuY3VycmVudCB8fCAhXy5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGIuY3VycmVudCA9ICEwO1xuICAgIGNvbnN0IHcgPSBfLmN1cnJlbnQ7XG4gICAgcCA/IChmKFwiaW5pdFwiLCBwLCB7XG4gICAgICAuLi51LFxuICAgICAgb3JpZ2luOiB5XG4gICAgfSksIGYubnNbcF0oXCJpbmxpbmVcIiwge1xuICAgICAgZWxlbWVudE9yU2VsZWN0b3I6IHcsXG4gICAgICBjYWxMaW5rOiBtLFxuICAgICAgY29uZmlnOiBSXG4gICAgfSkpIDogKGYoXCJpbml0XCIsIHtcbiAgICAgIC4uLnUsXG4gICAgICBvcmlnaW46IHlcbiAgICB9KSwgZihcImlubGluZVwiLCB7XG4gICAgICBlbGVtZW50T3JTZWxlY3RvcjogdyxcbiAgICAgIGNhbExpbms6IG0sXG4gICAgICBjb25maWc6IFJcbiAgICB9KSk7XG4gIH0sIFtmLCBtLCBSLCBwLCB5LCB1XSksIGYgPyAvKiBAX19QVVJFX18gKi8gZ3IoXCJkaXZcIiwge1xuICAgIHJlZjogXyxcbiAgICAuLi5sXG4gIH0pIDogbnVsbDtcbn0sIGhyID0gbXI7XG5mdW5jdGlvbiBFcihDKSB7XG4gIGNvbnN0IGcgPSB0eXBlb2YgQyA9PSBcInN0cmluZ1wiID8geyBlbWJlZEpzVXJsOiBDIH0gOiBDID8/IHt9LCB7IG5hbWVzcGFjZTogbSA9IFwiXCIsIGVtYmVkSnNVcmw6IHkgfSA9IGc7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBwKFIpIHtcbiAgICBjb25zdCB1ID0gWCh5KTtcbiAgICB1KFwiaW5pdFwiLCBtKTtcbiAgICBjb25zdCBkID0gbSA/IHUubnNbbV0gOiB1O1xuICAgIGlmICghZCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHAoUik7XG4gICAgICB9LCA1MCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFIoZCk7XG4gIH0pO1xufVxuZXhwb3J0IHtcbiAgaHIgYXMgZGVmYXVsdCxcbiAgRXIgYXMgZ2V0Q2FsQXBpXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@calcom/embed-react/dist/Cal.es.mjs\n");

/***/ })

};
;